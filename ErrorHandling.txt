# Error Handling in Python

## Overview
Error handling in Python is done using try-except blocks to catch and handle exceptions that may occur during program execution. This prevents the program from crashing and allows for graceful error recovery.

## Basic Try-Except Block
The basic structure uses `try` to wrap code that might raise an exception, and `except` to handle it.

### Example:
```python
try:
    result = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero!")
```

## Catching Multiple Exceptions
You can catch multiple exception types in a single except block or use multiple except blocks.

### Example:
```python
try:
    num = int(input("Enter a number: "))
    result = 10 / num
except ValueError:
    print("Please enter a valid number!")
except ZeroDivisionError:
    print("Cannot divide by zero!")
```

## Using Else and Finally
- `else`: Executes if no exception occurs
- `finally`: Always executes, regardless of whether an exception occurred

### Example:
```python
try:
    file = open("example.txt", "r")
    content = file.read()
except FileNotFoundError:
    print("File not found!")
else:
    print("File read successfully!")
finally:
    if 'file' in locals():
        file.close()
```

## Raising Exceptions
You can manually raise exceptions using the `raise` keyword.

### Example:
```python
def check_age(age):
    if age < 0:
        raise ValueError("Age cannot be negative!")
    return age

try:
    check_age(-5)
except ValueError as e:
    print(f"Error: {e}")
```

## Custom Exceptions
Create your own exception classes by inheriting from the `Exception` class.

### Example:
```python
class InsufficientFundsError(Exception):
    pass

def withdraw(balance, amount):
    if amount > balance:
        raise InsufficientFundsError("Not enough funds!")
    return balance - amount

try:
    withdraw(100, 150)
except InsufficientFundsError as e:
    print(f"Transaction failed: {e}")
```

## Common Built-in Exceptions
- `ValueError`: Raised when a function receives an argument of the right type but inappropriate value
- `TypeError`: Raised when an operation or function is applied to an object of inappropriate type
- `IndexError`: Raised when a sequence subscript is out of range
- `KeyError`: Raised when a dictionary key is not found
- `FileNotFoundError`: Raised when a file or directory is requested but doesn't exist
- `ZeroDivisionError`: Raised when division or modulo by zero occurs

## Best Practices
1. Catch specific exceptions rather than using a bare `except`
2. Use `finally` for cleanup operations
3. Don't suppress exceptions unnecessarily
4. Provide meaningful error messages
5. Consider logging exceptions for debugging

## Example: Comprehensive Error Handling
```python
import logging

logging.basicConfig(level=logging.ERROR)

def safe_division(a, b):
    try:
        result = a / b
    except ZeroDivisionError:
        logging.error("Division by zero attempted")
        return None
    except TypeError:
        logging.error("Invalid types for division")
        return None
    else:
        return result
    finally:
        print("Division operation completed")

# Usage
print(safe_division(10, 2))  # Output: 5.0
print(safe_division(10, 0))  # Output: None (with error logged)
```